ls | wc -l > output.txt

_____________________________________________________________________________________

LEXER
|, > => TOKEN
ls, wc -l, output.txt => commande

_____________________________________________________________________________________

QUOTES
'<quelque chose>' peut importe ce qu'est <quelque chose> print as it is sans print '
"<truc>" print <truc> sans " mais si il y'a des '' dans des "" il faut les print"

_____________________________________________________________________________________

PARSER
debut => |
ls commande
| => >
wc -l commande
>
output.txt fichier

Apres une redirection -> check si 1 str apres != \ / : * ? < > |
sinon return error

conmand = ls
command = wc -l > output.txt

ls < infile1 > outfile1 < infile2 -la < infile3 > outfile3 | ls > outfile4 < infile4

typedef struct s_simple_cmds
{
	char                    **str;
	int                     (*builtin)(t_tools *, struct s_simple_cmds *);
	int                     num_redirections;
	char                    *hd_file_name;
	t_lexer                 *redirections;
	struct s_simple_cmds	*next;
	struct s_simple_cmds	*prev;
}	t_simple_cmds;

command :

ls -l | echo a > file

[[[ls] [-l]] [|] [[echo a] [>] [file]]]

split by | :
ls -l
echo a > file

check each command:
char ** = ls -l
builtin = NULL
redirection = NULL

char ** = echo a
builtin = echo
redirection = > file

DOLLAR

$$ = <pid>
$-truc = "himBHstruc"
$( = unclosed (ou $' ou $" ou $[ ou ${ ou $| ou $`)
$) = syntax error near unexpected token `)' (`ou $] ou $})
$< = syntax error near unexpected token `newline' (`ou $>)

DOLLAR DONE
$_truc = ""
$#truc = 0truc
$ = ""
$5behdu = "behdu"
$!truc = "truc" (ou $@ ou $* ou chiffre)
$USER$USER = thibnguythibnguy
$USER$riri = thibnguy (ou $_truc (meme si truc == valid(envp))
$%truc = %truc (ou $^ ou $= ou $+ ou $, ou $. ou $/)
$USER$ = thibnguy$
$\truc = $truc (ou $~)

free exit_code = [3, 125]

_____________________________________________________________________________________

EXECUTEUR
ls
wc -l
> fichier

si fichier valide

exit code list :
0		: Successful exit without errors
1		: One or nore generic errors encountered upon exit
2		: Incorrect usage, such as invalid options or missing arguments
126		: Command found but is not executable
127		: Command not found, usually the result of a missing directory in $PATH variable
128+N	: Command encountered fatal error (was forcefully terminated manually or from an outside source).
		: The N tells us which signal was recieved
130		: Command terminated with signal 2 (SIGINT) (ctrl+c on keyboard). 128+2
143		: Command terminated with signal 15 (SIGTERM) (kill command). 128+15

BUILTINS

cd | echo | env | exit | export | pwd | unset