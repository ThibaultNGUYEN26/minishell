pour la commande : < input cat | echo "bonjour""comment ca va?"

il faut : < input cat | echo "bonjour" "comment ca va?"

data = 
[0] <
[1] input
[2] cat
[3] |
[4] echo
[5] "bonjour""comment
[6] ca
[7] va?"

"", ' ' , '', () 

pour avoir : data = 
[0] <
[1] input
[2] cat
[3] |
[4] echo
[5] bonjour
[6] comment ca va?


pour la commande : < input cat | "echo bonjour" = input

il faut reussir a detecter les tokens, les commandes, les mots
tel que liste des tokens : <<, <, >, >>, |, ', ", <space>, (BONUS) &&, ||

i = 0;
while i < strlen(input)
	j = i;
	if (str[i] == '<' || str[i] == '>' || str[i] == '<<' || str[i] == '>>' || str[i] == '|')
		addlastnode(data, str[i])
	else if (str[i] == '"' || str[i] == ''')
	{
		c = str[i];
		while (str[j] && str[j] != c)
			j++;
		// il faut gérer les cas où le " n'est pas fermé	
		if (!str[j])
			there is an error et je pense juste print le message d'erreur
		addlastnode(data, substr(input, i + 1, j));
		i = j + 1;
	}
	else if (str[i] == ' ')
		i++;
	else
	{
		// this is bare minimum pour $ il faudra bien tout gérer après
		if (str[i] == '$')
			search dans envp comme sur pipex et selectionner le resultat et update i
		else if (str[i] == '$' && str[i + 1] == '?')
			execute error function et i = i + 2
		// if letter normal and not variable d'environnement
		else
			// gerer si le dollar est dans la chaine
			while (str[j] != ' ' && str[j])
				j++;
		addlastnode(data, substr(input, i + 1, j));
		i = j;
	}
}
return (data);

DONC : le lexer doit split les tokens, separer ce qu'il y'a entre les quotes et gerer les $ en faisant en sorte que la liste avec les elements de la commande aie le resultat des variables d'env

il faut changer tout
while on est a un token mettre le token dans data
si pas token tant qu'on est pas a token ou fin d'input mettre tout ce qu'il y'a dans data

apres
gerer les doubles quotes (parser) 
et les dollars (expander)

Ligne a suivre : LEXER -> PARSER -> EXPANDER -> EXECUTEUR

things to fix :

echo $'allo' ou avec "" = allo
my output : ""


str
split avec dollar et avec ' '

